# 端口共享提权方案技术文档

## 问题背景

SerialMaster 的端口共享功能依赖 `com0com` 虚拟串口驱动。该驱动通过 `setupc.exe` 命令行工具来创建和管理虚拟串口对。

**核心问题**: `setupc.exe` 的 `install`、`remove` 等命令需要**管理员权限**才能执行，因为它们会修改系统驱动和注册表。

## 解决方案概述

采用 **PowerShell + UAC 弹窗** 的方式，在需要时自动请求用户授予管理员权限：

1. 先尝试以普通权限执行命令（如 `list`）
2. 对于需要提权的命令（如 `install`, `remove`），直接走提权路径
3. 如果普通执行失败且错误信息包含权限相关关键字，自动触发提权
4. 提权通过 PowerShell 的 `Start-Process -Verb RunAs` 实现

## 实现细节

### 1. 命令分类

```rust
// 判断是否需要管理员权限
let needs_elevation = args.first()
    .map(|cmd| matches!(*cmd, "install" | "remove" | "uninstall" | "busynames" | "change"))
    .unwrap_or(false);
```

### 2. 普通执行

对于 `list` 等只读命令，直接使用 `std::process::Command` 执行：

```rust
let output = Command::new(&self.setupc_path)
    .args(args)
    .current_dir(working_dir)
    .creation_flags(CREATE_NO_WINDOW)  // 不显示命令行窗口
    .output()?;
```

### 3. 提权执行 (run_elevated)

核心思路：使用 PowerShell 的 `Start-Process -Verb RunAs` 来触发 Windows UAC 弹窗。

```rust
fn run_elevated(&self, args: &[&str], working_dir: &std::path::Path) -> Result<String> {
    // 1. 创建临时输出文件（用于捕获提权进程的输出）
    let temp_dir = std::env::temp_dir();
    let output_file = temp_dir.join(format!("serial_master_setupc_{}.txt", std::process::id()));
    
    // 2. 构造 cmd 命令
    // 格式: cmd /S /C "cd /d WORKING_DIR && setupc.exe ARGS > OUTPUT 2>&1"
    let cmd_command = format!(
        "cd /d \"{}\" && \"{}\" {} > \"{}\" 2>&1",
        working_dir.to_string_lossy(),
        self.setupc_path.to_string_lossy(),
        args.join(" "),
        output_file.to_string_lossy()
    );
    
    // 3. 构造 PowerShell 命令
    let ps_script = format!(
        "Start-Process -FilePath 'cmd.exe' -ArgumentList '/S', '/C', '{}' -Verb RunAs -Wait",
        cmd_command.replace("'", "''")  // 转义 PowerShell 单引号
    );
    
    // 4. 执行 PowerShell（这会触发 UAC 弹窗）
    let status = Command::new("powershell")
        .args(&["-NoProfile", "-Command", &ps_script])
        .status()?;
    
    // 5. 读取输出文件
    let output_content = std::fs::read_to_string(&output_file)?;
    
    // 6. 清理临时文件
    let _ = std::fs::remove_file(&output_file);
    
    Ok(output_content)
}
```

### 4. 权限错误检测

当普通执行失败时，检测错误信息：

```rust
// 组合 stdout 和 stderr 来检测错误
let combined_output = format!("{} {}", stdout, stderr);

// 宽容匹配权限相关错误
if combined_output.contains("failed 5")           // Windows 错误码 5 = ACCESS_DENIED
   || combined_output.to_lowercase().contains("denied") 
   || combined_output.contains("拒绝访问") {      // 中文系统
    return self.run_elevated(args, working_dir);
}
```

## 关键技术点

### 为什么用 PowerShell 而不是直接的 Rust 提权？

1. **Rust 标准库不支持**: `std::process::Command` 没有直接的 "以管理员运行" 选项
2. **Windows API 复杂**: 使用 `ShellExecuteEx` 需要额外的 Windows FFI 绑定
3. **PowerShell 简单可靠**: `Start-Process -Verb RunAs` 是 Windows 官方推荐的提权方式

### 输出捕获问题

提权后的进程运行在独立的会话中，其 stdout/stderr 无法直接通过管道捕获。解决方案：
- 将输出重定向到临时文件 (`> output.txt 2>&1`)
- 提权进程结束后读取临时文件内容

### CREATE_NO_WINDOW 标志

```rust
const CREATE_NO_WINDOW: u32 = 0x08000000;
```

用于隐藏命令行窗口闪烁，提升用户体验。

## 潜在问题与解决

### 1. UAC 被禁用

如果用户禁用了 UAC，`-Verb RunAs` 可能静默失败。
**解决**: 检查 `status.success()` 并给出明确错误提示。

### 2. 中文路径

路径包含中文字符时可能出现编码问题。
**解决**: 使用 `to_string_lossy()` 并确保 cmd 使用正确的代码页。

### 3. 杀毒软件拦截

某些杀毒软件可能拦截 PowerShell 执行。
**解决**: 添加软件白名单或提示用户临时关闭防护。

## 文件位置

- 后端实现: `src/core/com0com_manager.rs`
- 前端调用: `src/ui/src/services/ipc.ts` -> `PortSharingService`
- UI 控件: `src/ui/src/components/PortSharingToggle.tsx`
